/**********************************************************************

  Audacity: A Digital Audio Editor

  WaveTrack.cpp

  Dominic Mazzoni

*******************************************************************//**

\class WaveTrack
\brief A Track that contains audio waveform data.

*//****************************************************************//**

\class WaveTrack::Location
\brief Used only by WaveTrack, a special way to hold location that
can accommodate merged regions.

*//****************************************************************/

/*!
@class WaveTrackFactory
@brief Used to create or clone a WaveTrack, with appropriate context
from the project that will own the track.
*/


#include "WaveTrack.h"

#include "WideClip.h"
#include "WaveClip.h"

#include <wx/defs.h>
#include <wx/debug.h>
#include <wx/log.h>

#include <float.h>
#include <math.h>
#include <algorithm>
#include <optional>
#include <numeric>

#include "float_cast.h"

#include "AudioSegmentSampleView.h"
#include "Envelope.h"
#include "Sequence.h"

#include "Project.h"
#include "ProjectRate.h"

#include "Prefs.h"
#include "SyncLock.h"
#include "TimeWarper.h"
#include "QualitySettings.h"

#include "InconsistencyException.h"

#include "ProjectFormatExtensionsRegistry.h"

using std::max;

namespace {
struct WaveTrackData : ClientData::Cloneable<> {
   WaveTrackData() = default;
   WaveTrackData(const WaveTrackData &);
   WaveTrackData& operator=(const WaveTrackData &) = delete;
   ~WaveTrackData() override;
   std::unique_ptr<ClientData::Cloneable<>> Clone() const override;

   static WaveTrackData &Get(WaveTrack &track);
   static const WaveTrackData &Get(const WaveTrack &track);

   float GetGain() const;
   void SetGain(float value);
   float GetPan() const;
   void SetPan(float value);

   double GetRate() const;
   void SetRate(double value);

private:
   //! Atomic because it may be read by worker threads in playback
   std::atomic<float> mGain{ 1.0f };
   //! Atomic because it may be read by worker threads in playback
   std::atomic<float> mPan{ 0.0f };

   int mRate{ 44100 };
};

static const Track::ChannelGroupAttachments::RegisteredFactory
waveTrackDataFactory{
   [](auto &) { return std::make_unique<WaveTrackData>(); } };

//! Copy can't be generated by default because of mutable members
WaveTrackData::WaveTrackData(const WaveTrackData &other) {
   SetGain(other.GetGain());
   SetPan(other.GetPan());
   mRate = other.mRate;
}

WaveTrackData::~WaveTrackData() = default;

std::unique_ptr<ClientData::Cloneable<>> WaveTrackData::Clone() const {
   return std::make_unique<WaveTrackData>(*this);
}

WaveTrackData &WaveTrackData::Get(WaveTrack &track) {
   return track.GetGroupData().Track::ChannelGroupAttachments
      ::Get<WaveTrackData>(waveTrackDataFactory);
}

const WaveTrackData &WaveTrackData::Get(const WaveTrack &track)
{
   return Get(const_cast<WaveTrack &>(track));
}

float WaveTrackData::GetGain() const
{
   return mGain.load(std::memory_order_relaxed);
}

void WaveTrackData::SetGain(float value)
{
   mGain.store(value, std::memory_order_relaxed);
}

float WaveTrackData::GetPan() const
{
   return mPan.load(std::memory_order_relaxed);
}

void WaveTrackData::SetPan(float value)
{
   mPan.store(value, std::memory_order_relaxed);
}

double WaveTrackData::GetRate() const
{
   return mRate;
}

void WaveTrackData::SetRate(double value)
{
   mRate = value;
}

bool AreAligned(const WaveClipPointers& a, const WaveClipPointers& b)
{
   if (a.size() != b.size())
      return false;

   const auto compare = [](const WaveClip* a, const WaveClip* b) {
      // clips are aligned if both sequence start/end
      // points and play start/end points of the first clip match
      // the corresponding points of the other clip
      return a->GetPlayStartTime() == b->GetPlayStartTime() &&
             a->GetSequenceStartTime() == b->GetSequenceStartTime() &&
             a->GetPlayEndTime() == b->GetPlayEndTime() &&
             a->GetSequenceEndTime() == b->GetSequenceEndTime();
   };

   return std::mismatch(a.begin(), a.end(), b.begin(), compare).first == a.end();
}

//Handles possible future file values
Track::LinkType ToLinkType(int value)
{
   if (value < 0)
      return Track::LinkType::None;
   else if (value > 3)
      return Track::LinkType::Group;
   return static_cast<Track::LinkType>(value);
}

}

static auto DefaultName = XO("Audio");

wxString WaveTrack::GetDefaultAudioTrackNamePreference()
{
   const auto name = AudioTrackNameSetting.ReadWithDefault(L"");

   if (name.empty() || ( name == DefaultName.MSGID() ))
      // When nothing was specified,
      // the default-default is whatever translation of...
      /* i18n-hint: The default name for an audio track. */
      return DefaultName.Translation();
   else
      return name;
}

static ProjectFileIORegistry::ObjectReaderEntry readerEntry{
   "wavetrack",
   WaveTrack::New
};

std::shared_ptr<WaveTrack> WaveTrackFactory::Create()
{
   return Create(QualitySettings::SampleFormatChoice(), mRate.GetRate());
}

std::shared_ptr<WaveTrack> WaveTrackFactory::Create(sampleFormat format, double rate)
{
   return std::shared_ptr<WaveTrack>(new WaveTrack(mpFactory, format, rate));
}

WaveTrack *WaveTrack::New( AudacityProject &project )
{
   auto &trackFactory = WaveTrackFactory::Get( project );
   auto &tracks = TrackList::Get( project );
   auto result = tracks.Add(trackFactory.Create());
   result->AttachedTrackObjects::BuildAll();
   return result;
}

WaveTrack::WaveTrack(
   const SampleBlockFactoryPtr& pFactory, sampleFormat format, double rate)
    : WritableSampleTrack()
    , mpFactory(pFactory)
{
   mLegacyProjectFileOffset = 0;

   mFormat = format;
   SetRate(static_cast<int>(rate));
   mWaveColorIndex = 0;
}

WaveTrack::WaveTrack(const WaveTrack& orig, ProtectedCreationArg&& a)
    : WritableSampleTrack(orig, std::move(a))
    , mpFactory(orig.mpFactory)
{
   mLegacyProjectFileOffset = 0;
   for (const auto &clip : orig.mClipList.Get())
      mClipList.PushBack(std::make_shared<WaveClip>(*clip, mpFactory, true));
}

size_t WaveTrack::GetWidth() const
{
   return 1;
}

size_t WaveTrack::NChannels() const
{
   if (IsLeader()) {
      auto result = TrackList::NChannels(*this);
      assert(result > 0);
      return result;
   }
   else
      return 1;
}

AudioGraph::ChannelType WaveTrack::GetChannelType() const
{
   if (TrackList::NChannels(*this) == 1)
      return AudioGraph::MonoChannel;
   else if (IsLeader())
      return AudioGraph::LeftChannel;
   else
      // TODO more-than-two-channels
      return AudioGraph::RightChannel;
}

// Copy the track metadata but not the contents.
void WaveTrack::Init(const WaveTrack &orig)
{
   WritableSampleTrack::Init(orig);
   mpFactory = orig.mpFactory;

   mFormat = orig.mFormat;
   mWaveColorIndex = orig.mWaveColorIndex;
}

void WaveTrack::Reinit(const WaveTrack &orig)
{
   Init(orig);

   // Copy attached data from orig.  Nullify data in this where orig had null.
   Attachments &attachments = *this;
   attachments = orig;
}

void WaveTrack::Merge(const Track &orig)
{
   orig.TypeSwitch( [&](const WaveTrack &wt) {
      // Copy attached data from orig.  Nullify data in this where orig had null.
      Attachments &attachments = *this;
      attachments = wt;
   });
}

WaveTrack::~WaveTrack()
{
}

double WaveTrack::GetOffset(BPS tempo) const
{
   return GetStartTime(tempo);
}

/*! @excsafety{No-fail} */
void WaveTrack::SetOffset(double o, BPS tempo)
{
   const auto trackList = GetOwner();
   if(trackList) {
      const auto project = trackList->GetOwner();

   }
   double delta = o - GetOffset(tempo);

   for (const auto &clip : mClipList.Get())
      // assume No-fail-guarantee
      clip->Offset(delta, tempo);

   mOffset = Beat { tempo.get() * o };
}

void WaveTrack::SetProjectTempo(double newTempo)
{
   mClipList.SetProjectTempo(newTempo);
   mProjectTempo = newTempo;
}

bool WaveTrack::LinkConsistencyFix(bool doFix, bool completeList)
{
   auto err = !WritableSampleTrack::LinkConsistencyFix(doFix, completeList);
   if (completeList) {
      auto linkType = GetLinkType();
      if (static_cast<int>(linkType) == 1 || //Comes from old audacity version
          linkType == LinkType::Aligned) {
         auto next =
            dynamic_cast<WaveTrack*>(*std::next(GetOwner()->Find(this)));
         if (next == nullptr) {
            //next track is absent or not a wave track, fix and report error
            if (doFix) {
               wxLogWarning(L"Right track %s is expected to be a WaveTrack."
                  "\n Removing link from left wave track %s.",
                  next->GetName(), GetName());
               SetLinkType(LinkType::None);
            }
            err = true;
         }
         else if (doFix) {
            // non-error upgrades happen here
            auto newLinkType =
               AreAligned(SortedClipArray(), next->SortedClipArray())
               ? LinkType::Aligned : LinkType::Group;
            if (newLinkType != linkType)
               SetLinkType(newLinkType);
            else
               // Be sure to lose any right channel group data that might
               // have been made during during deserialization of the channel
               // before joining it
               next->DestroyGroupData();
         }
      }
      if (doFix) {
         // More non-error upgrading
         // Set the common channel group rate from the leader's rate
         if (IsLeader() && mLegacyRate > 0) {
            SetRate(mLegacyRate);
            mLegacyRate = 0;
         }
      }
   }
   return !err;
}

static const Track::TypeInfo &typeInfo()
{
   static const Track::TypeInfo info{
      { "wave", "wave", XO("Wave Track") },
      true, &WritableSampleTrack::ClassTypeInfo() };
   return info;
}

auto WaveTrack::GetTypeInfo() const -> const TypeInfo &
{
   return typeInfo();
}

auto WaveTrack::ClassTypeInfo() -> const TypeInfo &
{
   return typeInfo();
}

template <typename Container>
static Container MakeIntervals(const WaveClipHolders& clips, BPS tempo)
{
   Container result;
   for (const auto &clip: clips) {
      result.emplace_back(
         clip->GetPlayStartTime(tempo), clip->GetPlayEndTime(tempo), tempo,
         std::make_unique<WaveTrack::IntervalData>(clip));
   }
   return result;
}

Track::Holder
WaveTrack::PasteInto(AudacityProject& project, BPS otherProjectTempo) const
{
   auto &trackFactory = WaveTrackFactory::Get( project );
   auto &pSampleBlockFactory = trackFactory.GetSampleBlockFactory();
   auto pNewTrack = EmptyCopy( pSampleBlockFactory );
   pNewTrack->Paste(0.0, otherProjectTempo, this);
   return pNewTrack;
}

auto WaveTrack::GetIntervals(BPS tempo) const -> ConstIntervals
{
   return MakeIntervals<ConstIntervals>(mClipList.Get(), tempo);
}

auto WaveTrack::GetIntervals(BPS tempo) -> Intervals
{
   return MakeIntervals<Intervals>(mClipList.Get(), tempo);
}

const WaveClip* WaveTrack::FindClipByName(const wxString& name) const
{
   for (const auto& clip : mClipList.Get())
   {
      if (clip->GetName() == name)
         return clip.get();
   }
   return nullptr;
}

Track::Holder WaveTrack::Clone() const
{
   auto result = std::shared_ptr<WaveTrack>(new WaveTrack(*this, ProtectedCreationArg{}));
   result->Init(*this);
   return result;
}

wxString WaveTrack::MakeClipCopyName(const wxString& originalName) const
{
   auto name = originalName;
   for (auto i = 1;; ++i)
   {
      if (FindClipByName(name) == nullptr)
         return name;
      //i18n-hint Template for clip name generation on copy-paste
      name = XC("%s.%i", "clip name template").Format(originalName, i).Translation();
   }
}

wxString WaveTrack::MakeNewClipName() const
{
   auto name = GetName();
   for (auto i = 1;; ++i)
   {
      if (FindClipByName(name) == nullptr)
         return name;
      //i18n-hint Template for clip name generation on inserting new empty clip
      name = XC("%s %i", "clip name template").Format(GetName(), i).Translation();
   }
}

double WaveTrack::GetRate() const
{
   return WaveTrackData::Get(*this).GetRate();
}

void WaveTrack::SetRate(double newRate)
{
   wxASSERT( newRate > 0 );
   newRate = std::max( 1.0, newRate );
   auto &data = WaveTrackData::Get(*this);
   data.SetRate(static_cast<int>(newRate));
   SetClipRates(newRate);
}

void WaveTrack::SetClipRates(double newRate)
{
   auto ratio = GetRate() / newRate;
   constexpr auto reposition = true;
   for (const auto &clip : mClipList.Get())
      clip->SetRate((int)newRate, reposition);
}

float WaveTrack::GetGain() const
{
   return WaveTrackData::Get(*this).GetGain();
}

void WaveTrack::DoSetGain(float value)
{
   WaveTrackData::Get(*this).SetGain(value);
}

void WaveTrack::SetGain(float newGain)
{
   if (GetGain() != newGain) {
      DoSetGain(newGain);
      Notify(true);
   }
}

float WaveTrack::GetPan() const
{
   return WaveTrackData::Get(*this).GetPan();
}

void WaveTrack::DoSetPan(float value)
{
   WaveTrackData::Get(*this).SetPan(value);
}

void WaveTrack::SetPan(float newPan)
{
   if (newPan > 1.0)
      newPan = 1.0;
   else if (newPan < -1.0)
      newPan = -1.0;

   if ( GetPan() != newPan ) {
      DoSetPan(newPan);
      Notify(true);
   }
}

float WaveTrack::GetChannelGain(int channel) const
{
   float left = 1.0;
   float right = 1.0;

   const auto pan = GetPan();
   if (pan < 0)
      right = (pan + 1.0);
   else if (pan > 0)
      left = 1.0 - pan;

   const auto gain = GetGain();
   if ((channel%2) == 0)
      return left * gain;
   else
      return right * gain;
}

/*! @excsafety{Strong} */
void WaveTrack::SetWaveColorIndex(int colorIndex)
{
   for (const auto &clip : mClipList.Get())
      clip->SetColourIndex( colorIndex );
   mWaveColorIndex = colorIndex;
}

sampleCount WaveTrack::GetPlaySamplesCount() const
{
    sampleCount result{ 0 };

    for (const auto& clip : mClipList.Get())
        result += clip->GetPlaySamplesCount();

    return result;
}

sampleCount WaveTrack::GetSequenceSamplesCount() const
{
   sampleCount result{ 0 };

   for (const auto& clip : mClipList.Get())
      result += clip->GetSequenceSamplesCount();

   return result;
}

/*! @excsafety{Weak} -- Might complete on only some clips */
void WaveTrack::ConvertToSampleFormat(sampleFormat format,
   const std::function<void(size_t)> & progressReport)
{
   for (const auto& clip : mClipList.Get())
      clip->ConvertToSampleFormat(format, progressReport);
   mFormat = format;
}


bool WaveTrack::IsEmpty(double t0, double t1, BPS tempo) const
{
   if (t0 > t1)
      return true;

   //wxPrintf("Searching for overlap in %.6f...%.6f\n", t0, t1);
   for (const auto &clip : mClipList.Get())
   {
      if (
         !clip->BeforeOrAtPlayStartTime(t1, tempo) &&
         !clip->AfterOrAtPlayEndTime(t0, tempo))
      {
         // wxPrintf("Overlapping clip: %.6f...%.6f\n",
         //       clip->GetStartTime(tempo),
         //       clip->GetEndTime(tempo));
         // We found a clip that overlaps this region
         return false;
      }
   }
   //wxPrintf("No overlap found\n");

   // Otherwise, no clips overlap this region
   return true;
}

Track::Holder WaveTrack::Cut(double t0, double t1, BPS tempo)
{
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   auto tmp = Copy(t0, t1, tempo);

   Clear(t0, t1, tempo);

   return tmp;
}

/*! @excsafety{Strong} */
Track::Holder WaveTrack::SplitCut(double t0, double t1, BPS tempo)
{
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   // SplitCut is the same as 'Copy', then 'SplitDelete'
   auto tmp = Copy(t0, t1, tempo);

   SplitDelete(t0, t1, tempo);

   return tmp;
}

#if 0
Track::Holder WaveTrack::CutAndAddCutLine(double t0, double t1, BPS tempo)
{
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   // Cut is the same as 'Copy', then 'Delete'
   auto tmp = Copy(t0, t1);

   ClearAndAddCutLine(t0, t1);

   return tmp;
}
#endif



//Trim trims within a clip, rather than trimming everything.
//If a bound is outside a clip, it trims everything.
/*! @excsafety{Weak} */
void WaveTrack::Trim(double t0, double t1, BPS tempo)
{
   bool inside0 = false;
   bool inside1 = false;

   for (const auto &clip : mClipList.Get())
   {
      if (
         t1 > clip->GetPlayStartTime(tempo) && t1 < clip->GetPlayEndTime(tempo))
      {
         clip->SetTrimRight(
            clip->GetTrimRight(tempo) + clip->GetPlayEndTime(tempo) - t1, tempo);
         inside1 = true;
      }

      if (
         t0 > clip->GetPlayStartTime(tempo) && t0 < clip->GetPlayEndTime(tempo))
      {
         clip->SetTrimLeft(
            clip->GetTrimLeft(tempo) + t0 - clip->GetPlayStartTime(tempo),
            tempo);
         inside0 = true;
      }
   }

   //if inside0 is false, then the left selector was between
   //clips, so DELETE everything to its left.
   if(!inside1 && t1 < GetEndTime(tempo))
      Clear(t1,GetEndTime(tempo), tempo);

   if(!inside0 && t0 > GetStartTime(tempo))
      SplitDelete(GetStartTime(tempo), t0, tempo);
}




WaveTrack::Holder WaveTrack::EmptyCopy(
   const SampleBlockFactoryPtr &pFactory, bool keepLink) const
{
   auto result = std::shared_ptr<WaveTrack>(new WaveTrack(pFactory, mFormat, GetRate()));
   result->Init(*this);
   result->mpFactory = pFactory ? pFactory : mpFactory;
   if (!keepLink)
      result->SetLinkType(LinkType::None);
   return result;
}

Track::Holder
WaveTrack::Copy(double t0, double t1, BPS tempo, bool forClipboard) const
{
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   auto result = EmptyCopy();
   WaveTrack *newTrack = result.get();

   // PRL:  Why shouldn't cutlines be copied and pasted too?  I don't know, but
   // that was the old behavior.  But this function is also used by the
   // Duplicate command and I changed its behavior in that case.
   for (const auto &clip : mClipList.Get())
   {
      if (
         t0 <= clip->GetPlayStartTime(tempo) &&
         t1 >= clip->GetPlayEndTime(tempo))
      {
         // Whole clip is in copy region
         //wxPrintf("copy: clip %i is in copy region\n", (int)clip);

         newTrack->mClipList.PushBack
            (std::make_shared<WaveClip>(*clip, mpFactory, ! forClipboard));
         WaveClip *const newClip = newTrack->mClipList.Back().get();
         newClip->Offset(-t0, tempo);
      }
      else if (clip->CountSamples(t0, t1, tempo) >= 1)
      {
         // Clip is affected by command
         //wxPrintf("copy: clip %i is affected by command\n", (int)clip);

         auto newClip = std::make_shared<WaveClip>(
            *clip, mpFactory, !forClipboard, t0, t1, tempo);
         newClip->SetName(clip->GetName());

         newClip->Offset(-t0, tempo);
         if (newClip->GetPlayStartTime(tempo) < 0)
            newClip->SetPlayStartTime(0, tempo);

         newTrack->mClipList.PushBack(std::move(newClip)); // transfer ownership
      }
   }

   // AWD, Oct 2009: If the selection ends in whitespace, create a placeholder
   // clip representing that whitespace
   // PRL:  Only if we want the track for pasting into other tracks.  Not if it
   // goes directly into a project as in the Duplicate command.
   if (
      forClipboard &&
      newTrack->GetEndTime(tempo) + 1.0 / newTrack->GetRate() < t1 - t0)
   {
      // TODO wide wave tracks -- match clip width of newTrack
      auto placeholder = std::make_shared<WaveClip>(1, mpFactory,
         newTrack->GetSampleFormat(),
         static_cast<int>(newTrack->GetRate()),
         0 /*colourindex*/);
      placeholder->SetIsPlaceholder(true);
      placeholder->InsertSilence(
         0, (t1 - t0) - newTrack->GetEndTime(tempo), tempo);
      placeholder->Offset(newTrack->GetEndTime(tempo), tempo);
      newTrack->mClipList.PushBack(std::move(placeholder)); // transfer ownership
   }

   return result;
}

Track::Holder WaveTrack::CopyNonconst(double t0, double t1, BPS tempo)
{
   return Copy(t0, t1, tempo);
}

/*! @excsafety{Strong} */
void WaveTrack::Clear(double t0, double t1, BPS tempo)
{
   HandleClear(t0, t1, tempo, false, false);
}

/*! @excsafety{Strong} */
void WaveTrack::ClearAndAddCutLine(double t0, double t1, BPS tempo)
{
   HandleClear(t0, t1, tempo, true, false);
}

namespace {

   //Internal structure, which is supposed to contain
   //data related to clip boundaries, and used during
   //ClearAndPaste to restore old splits after new
   //data is pasted
   struct SplitInfo
   {
      //Time, where boundary is located
      double time;
      //Contains trimmed data, which should be re-appended to
      //the clip to the left from the boundary, may be null
      std::shared_ptr<WaveClip> left;
      //Contains trimmed data, which should be re-appended to
      //the clip to the right from the boundary, may be null
      std::shared_ptr<WaveClip> right;
      //Contains clip name next to the left from the boundary,
      //if present, that needs to be re-assigned to the matching
      //clip after split
      std::optional<wxString> leftClipName;
      //Contains clip name next to the right from the boundary,
      //if present, that needs to be re-assigned to the matching
      //clip after split
      std::optional<wxString> rightClipName;
   };

}

//
// ClearAndPaste() is a specialized version of HandleClear()
// followed by Paste() and is used mostly by effects that
// can't replace track data directly using Get()/Set().
//
// HandleClear() removes any cut/split lines with the
// cleared range, but, in most cases, effects want to preserve
// the existing cut/split lines, trimmed data and clip names,
// so they are saved before the HandleClear()/Paste() and restored after.
// When pasted track has split lines with hidden data at same places
// as the target one, then only targets hidden data is preserved, and
// hidden data from pasted track is discarded.
//
// If the pasted track overlaps two or more clips, then it will
// be pasted with visible split lines.  Normally, effects do not
// want these extra lines, so they may be merged out.
//
/*! @excsafety{Weak} -- This WaveTrack remains destructible in case of AudacityException.
But some of its cutline clips may have been destroyed. */
void WaveTrack::ClearAndPaste(
   double t0, // Start of time to clear
   double t1, // End of time to clear
   BPS tempo,
   const Track* src,              // What to paste
   bool preserve,                 // Whether to reinsert splits/cuts
   bool merge,                    // Whether to remove 'extra' splits
   const TimeWarper* effectWarper // How does time change
)
{
   double dur = std::min(t1 - t0, src->GetEndTime(tempo));

   // If duration is 0, then it's just a plain paste
   if (dur == 0.0) {
      // use Weak-guarantee
      Paste(t0, tempo, src);
      return;
   }

   std::vector<SplitInfo> splits;
   WaveClipHolders cuts;

   //helper routine, that finds SplitInfo by time value,
   //or creates a new one if no one exists yet
   auto get_split = [&](double time) {
      auto it = std::find_if(splits.begin(), splits.end(), [time](const SplitInfo& split) {
         return split.time == time;
      });
      if(it == splits.end())
         it = splits.insert(
            splits.end(),
            { time, nullptr, nullptr, std::nullopt, std::nullopt }
         );
      return it;
   };

   // If provided time warper was NULL, use a default one that does nothing
   IdentityTimeWarper localWarper;
   const TimeWarper *warper = (effectWarper ? effectWarper : &localWarper);

   // Align to a sample
   t0 = LongSamplesToTime(TimeToLongSamples(t0));
   t1 = LongSamplesToTime(TimeToLongSamples(t1));

   // Save the cut/split lines whether preserving or not since merging
   // needs to know if a clip boundary is being crossed since Paste(tempo)
   // will add split lines around the pasted clip if so.
   for (const auto &clip : mClipList.Get()) {
      double st;

      // Remember clip boundaries as locations to split
      // we need to copy clips, trims and names, because the original ones
      // could be changed later during Clear/Paste routines
      st = LongSamplesToTime(TimeToLongSamples(clip->GetPlayStartTime(tempo)));
      if (st >= t0 && st <= t1) {
         auto it = get_split(st);
         if (clip->GetTrimLeft(tempo) != 0)
         {
            //keep only hidden left part
            it->right = std::make_shared<WaveClip>(*clip, mpFactory, false);
            it->right->SetTrimLeft(.0, tempo);
            it->right->ClearRight(clip->GetPlayStartTime(tempo), tempo);
         }
         it->rightClipName = clip->GetName();
      }

      st = LongSamplesToTime(TimeToLongSamples(clip->GetPlayEndTime(tempo)));
      if (st >= t0 && st <= t1) {
         auto it = get_split(st);
         if (clip->GetTrimRight(tempo) != 0)
         {
            //keep only hidden right part
            it->left = std::make_shared<WaveClip>(*clip, mpFactory, false);
            it->left->SetTrimRight(.0, tempo);
            it->left->ClearLeft(clip->GetPlayEndTime(tempo), tempo);
         }
         it->leftClipName = clip->GetName();
      }

      // Search for cut lines
      auto &cutlines = clip->GetCutLines();
      // May erase from cutlines, so don't use range-for
      for (auto it = cutlines.begin(); it != cutlines.end(); ) {
         WaveClip *cut = it->get();
         double cs = LongSamplesToTime(TimeToLongSamples(
            clip->GetSequenceStartTime(tempo) +
            cut->GetSequenceStartTime(tempo)));

         // Remember cut point
         if (cs >= t0 && cs <= t1) {

            // Remember the absolute offset and add to our cuts array.
            cut->SetSequenceStartTime(cs, tempo);
            cuts.push_back(std::move(*it)); // transfer ownership!
            it = cutlines.erase(it);
         }
         else
            ++it;
      }
   }

   const auto tolerance = 2.0 / GetRate();

   // Now, clear the selection
   HandleClear(t0, t1, tempo, false, false);
   {

      // And paste in the NEW data
      Paste(t0, tempo, src);
      {
         // First, merge the NEW clip(s) in with the existing clips
         if (merge && splits.size() > 0)
         {
            // Now t1 represents the absolute end of the pasted data.
            t1 = t0 + src->GetEndTime(tempo);

            // Get a sorted array of the clips
            auto clips = SortedClipArray();

            // Scan the sorted clips for the first clip whose start time
            // exceeds the pasted regions end time.
            {
               WaveClip *prev = nullptr;
               for (const auto clip : clips) {
                  // Merge this clip and the previous clip if the end time
                  // falls within it and this isn't the first clip in the track.
                  if (fabs(t1 - clip->GetPlayStartTime(tempo)) < tolerance)
                  {
                     if (prev)
                        MergeClips(GetClipIndex(prev), GetClipIndex(clip));
                     break;
                  }
                  prev = clip;
               }
            }
         }

         // Refill the array since clips have changed.
         auto clips = SortedClipArray();

         {
            // Scan the sorted clips to look for the start of the pasted
            // region.
            WaveClip *prev = nullptr;
            for (const auto clip : clips) {
               if (prev) {
                  // It must be that clip is what was pasted and it begins where
                  // prev ends.
                  // use Weak-guarantee
                  MergeClips(GetClipIndex(prev), GetClipIndex(clip));
                  break;
               }
               if (fabs(t0 - clip->GetPlayEndTime(tempo)) < tolerance)
                  // Merge this clip and the next clip if the start time
                  // falls within it and this isn't the last clip in the track.
                  prev = clip;
               else
                  prev = nullptr;
            }
         }
      }

      // Restore cut/split lines
      if (preserve) {

         auto attachLeft = [tempo](WaveClip& target, WaveClip& src) {
            assert(target.GetWidth() == src.GetWidth());
            assert(target.GetTrimLeft(tempo) == 0);
            if (target.GetTrimLeft(tempo) != 0)
               return;

            auto trim = src.GetPlayEndTime(tempo) - src.GetPlayStartTime(tempo);
            auto success =
               target.Paste(target.GetPlayStartTime(tempo), tempo, src);
            assert(success); // because of precondition above
            target.SetTrimLeft(trim, tempo);
            // Play start time needs to be adjusted aft, tempoer
            // prepending data to the sequence
            target.Offset(-trim, tempo);
         };

         auto attachRight = [tempo](WaveClip& target, WaveClip& src) {
            assert(target.GetWidth() == src.GetWidth());
            assert(target.GetTrimRight(tempo) == 0);
            if (target.GetTrimRight(tempo) != 0)
               return;

            auto trim = src.GetPlayEndTime(tempo) - src.GetPlayStartTime(tempo);
            auto success =
               target.Paste(target.GetPlayEndTime(tempo), tempo, src);
            assert(success); // because of precondition above
            target.SetTrimRight(trim, tempo);
         };

         // Restore the split lines and trims, transforming the position appropriately
         for (const auto& split: splits) {
            auto at = LongSamplesToTime(TimeToLongSamples(warper->Warp(split.time)));
            for (const auto& clip : GetClips())
            {
               // Clips in split began as copies of a clip in the track,
               // therefore have the same width, satisfying preconditions to
               // attach
               if (clip->StrictlyWithinPlayRegion(at, tempo))
               {
                  auto newClip =
                     std::make_shared<WaveClip>(*clip, mpFactory, true);

                  clip->ClearRight(at, tempo);
                  newClip->ClearLeft(at, tempo);
                  if (split.left)
                     // clip was cleared right
                     attachRight(*clip, *split.left);
                  if (split.right)
                     // new clip was cleared left
                     attachLeft(*newClip, *split.right);
                  bool success = AddClip(std::move(newClip));
                  assert(success); // copied clip has same width and factory
                  break;
               }
               else if (
                  clip->GetPlayStartSample(tempo) == TimeToLongSamples(at) &&
                  split.right)
               {
                  // precondition satisfied because... ??
                  attachLeft(*clip, *split.right);
                  break;
               }
               else if (
                  clip->GetPlayEndSample(tempo) == TimeToLongSamples(at) &&
                  split.left)
               {
                  // precondition satisfied because... ??
                  attachRight(*clip, *split.left);
                  break;
               }
            }
         }

         //Restore clip names
         for (const auto& split : splits)
         {
            auto s = TimeToLongSamples(warper->Warp(split.time));
            for (auto& clip : GetClips())
            {
               if (
                  split.rightClipName.has_value() &&
                  clip->GetPlayStartSample(tempo) == s)
                  clip->SetName(*split.rightClipName);
               else if (
                  split.leftClipName.has_value() &&
                  clip->GetPlayEndSample(tempo) == s)
                  clip->SetName(*split.leftClipName);
            }
         }

         // Restore the saved cut lines, also transforming if time altered
         for (const auto &clip : mClipList.Get()) {
            double st;
            double et;

            st = clip->GetPlayStartTime(tempo);
            et = clip->GetPlayEndTime(tempo);

            // Scan the cuts for any that live within this clip
            for (auto it = cuts.begin(); it != cuts.end();) {
               WaveClip *cut = it->get();
               //cutlines in this array were orphaned previously
               double cs = cut->GetSequenceStartTime(tempo);

               // Offset the cut from the start of the clip and add it to
               // this clips cutlines.
               if (cs >= st && cs <= et) {
                  cut->SetSequenceStartTime(warper->Warp(cs) - st, tempo);
                  clip->GetCutLines().push_back( std::move(*it) ); // transfer ownership!
                  it = cuts.erase(it);
               }
               else
                  ++it;
            }
         }
      }
   }
}

/*! @excsafety{Strong} */
void WaveTrack::SplitDelete(double t0, double t1, BPS tempo)
{
   bool addCutLines = false;
   bool split = true;
   HandleClear(t0, t1, tempo, addCutLines, split);
}

namespace
{
   WaveClipHolders::const_iterator
      FindClip(const WaveClipHolders &list, const WaveClip *clip, int *distance = nullptr)
   {
      if (distance)
         *distance = 0;
      auto it = list.begin();
      for (const auto end = list.end(); it != end; ++it)
      {
         if (it->get() == clip)
            break;
         if (distance)
            ++*distance;
      }
      return it;
   }

   WaveClipHolders::iterator
      FindClip(WaveClipHolders &list, const WaveClip *clip, int *distance = nullptr)
   {
      if (distance)
         *distance = 0;
      auto it = list.begin();
      for (const auto end = list.end(); it != end; ++it)
      {
         if (it->get() == clip)
            break;
         if (distance)
            ++*distance;
      }
      return it;
   }
}

std::shared_ptr<WaveClip> WaveTrack::RemoveAndReturnClip(WaveClip* clip)
{
   // Be clear about who owns the clip!!
   auto it = FindClip(mClipList.Get(), clip);
   if (it != mClipList.End()) {
      auto result = std::move(*it); // Array stops owning the clip, before we shrink it
      mClipList.Erase(it);
      return result;
   }
   else
      return {};
}

bool WaveTrack::AddClip(const std::shared_ptr<WaveClip> &clip)
{
   assert(clip);
   if (clip->GetSequence(0)->GetFactory() != this->mpFactory)
      return false;

   if (clip->GetWidth() != GetWidth())
      return false;

   // Uncomment the following line after we correct the problem of zero-length clips
   //if (CanInsertClip(clip))
   mClipList.PushBack(clip); // transfer ownership

   return true;
}

/*! @excsafety{Strong} */
void WaveTrack::HandleClear(
   double t0, double t1, BPS tempo, bool addCutLines, bool split)
{
   // For debugging, use an ASSERT so that we stop
   // closer to the problem.
   wxASSERT( t1 >= t0 );
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   bool editClipCanMove = GetEditClipsCanMove();

   WaveClipPointers clipsToDelete;
   WaveClipHolders clipsToAdd;

   // We only add cut lines when deleting in the middle of a single clip
   // The cut line code is not really prepared to handle other situations
   if (addCutLines)
   {
      for (const auto &clip : mClipList.Get())
      {
         if (
            !clip->BeforeOrAtPlayStartTime(t1, tempo) &&
            !clip->AfterOrAtPlayEndTime(t0, tempo) &&
            (clip->BeforeOrAtPlayStartTime(t0, tempo) ||
             clip->AfterOrAtPlayEndTime(t1, tempo)))
         {
            addCutLines = false;
            break;
         }
      }
   }

   for (const auto &clip : mClipList.Get())
   {
      if (
         clip->BeforeOrAtPlayStartTime(t0, tempo) &&
         clip->AfterOrAtPlayEndTime(t1, tempo))
      {
         // Whole clip must be deleted - remember this
         clipsToDelete.push_back(clip.get());
      }
      else if (
         !clip->BeforeOrAtPlayStartTime(t1, tempo) &&
         !clip->AfterOrAtPlayEndTime(t0, tempo))
      {
         // Clip data is affected by command
         if (addCutLines)
         {
            // Don't modify this clip in place, because we want a strong
            // guarantee, and might modify another clip
            clipsToDelete.push_back( clip.get() );
            auto newClip =
               std::make_shared<WaveClip>(*clip, mpFactory, true);
            newClip->ClearAndAddCutLine(t0, t1, tempo);
            clipsToAdd.push_back( std::move( newClip ) );
         }
         else
         {
            if (split) {
               // Three cases:

               if (clip->BeforeOrAtPlayStartTime(t0, tempo))
               {
                  // Delete from the left edge

                  // Don't modify this clip in place, because we want a strong
                  // guarantee, and might modify another clip
                  clipsToDelete.push_back( clip.get() );
                  auto newClip =
                     std::make_shared<WaveClip>(*clip, mpFactory, true);
                  newClip->TrimLeft(t1 - clip->GetPlayStartTime(tempo), tempo);
                  clipsToAdd.push_back( std::move( newClip ) );
               }
               else if (clip->AfterOrAtPlayEndTime(t1, tempo))
               {
                  // Delete to right edge

                  // Don't modify this clip in place, because we want a strong
                  // guarantee, and might modify another clip
                  clipsToDelete.push_back( clip.get() );
                  auto newClip =
                     std::make_shared<WaveClip>(*clip, mpFactory, true);
                  newClip->TrimRight(clip->GetPlayEndTime(tempo) - t0, tempo);

                  clipsToAdd.push_back( std::move( newClip ) );
               }
               else {
                  // Delete in the middle of the clip...we actually create two
                  // NEW clips out of the left and right halves...

                  auto leftClip =
                     std::make_shared<WaveClip>(*clip, mpFactory, true);
                  leftClip->TrimRight(clip->GetPlayEndTime(tempo) - t0, tempo);
                  clipsToAdd.push_back(std::move(leftClip));

                  auto rightClip =
                     std::make_shared<WaveClip>(*clip, mpFactory, true);
                  rightClip->TrimLeft(
                     t1 - rightClip->GetPlayStartTime(tempo), tempo);
                  clipsToAdd.push_back(std::move(rightClip));

                  clipsToDelete.push_back(clip.get());
               }
            }
            else {
               // (We are not doing a split cut)

               // Don't modify this clip in place, because we want a strong
               // guarantee, and might modify another clip
               clipsToDelete.push_back( clip.get() );
               auto newClip =
                  std::make_shared<WaveClip>(*clip, mpFactory, true);

               // clip->Clear keeps points < t0 and >= t1 via Envelope::CollapseRegion
               newClip->Clear(t0, t1, tempo);

               clipsToAdd.push_back( std::move( newClip ) );
            }
         }
      }
   }

   // Only now, change the contents of this track
   // use No-fail-guarantee for the rest

   if (!split && editClipCanMove)
   {
      // Clip is "behind" the region -- offset it unless we're splitting
      // or we're using the "don't move other clips" mode
      for (const auto& clip : mClipList.Get())
      {
         if (clip->BeforeOrAtPlayStartTime(t1, tempo))
            clip->Offset(-(t1 - t0), tempo);
      }
   }

   const auto& allClips = mClipList.Get();
   for (const auto &clip: clipsToDelete)
   {
      auto myIt = FindClip(allClips, clip);
      if (myIt != allClips.end())
         mClipList.Erase(myIt); // deletes the clip!
      else
         wxASSERT(false);
   }

   for (auto &clip: clipsToAdd)
      mClipList.PushBack(std::move(clip)); // transfer ownership
}

void WaveTrack::SyncLockAdjust(double oldT1, double newT1, BPS tempo)
{
   if (newT1 > oldT1) {
      // Insert space within the track

      // JKC: This is a rare case where using >= rather than > on a float
      // matters. GetEndTime(tempo) looks through the clips and may give us
      // EXACTLY the same value as T1, when T1 was set to be at the end of one
      // of those clips.
      if (oldT1 >= GetEndTime(tempo))
         return;

      // If track is empty at oldT1 insert whitespace; otherwise, silence
      if (IsEmpty(oldT1, oldT1, tempo))
      {
         // Check if clips can move
         if (EditClipsCanMove.Read()) {
            const auto offset = newT1 - oldT1;
            const auto rate = GetRate();
            for(const auto& clip : mClipList.Get())
            {
               if (clip->GetPlayStartTime(tempo) > oldT1 - (1.0 / rate))
                  clip->Offset(offset, tempo);
            }
         }
         return;
      }
      else {
         // AWD: Could just use InsertSilence() on its own here, but it doesn't
         // follow EditClipCanMove rules (Paste() does it right)
         auto tmp = std::shared_ptr<WaveTrack>(
            new WaveTrack(mpFactory, GetSampleFormat(), GetRate()));

         tmp->InsertSilence(0.0, newT1 - oldT1, tempo);
         tmp->Flush();
         Paste(oldT1, tempo, tmp.get());
      }
   }
   else if (newT1 < oldT1) {
      Clear(newT1, oldT1, tempo);
   }
}

void WaveTrack::PasteWaveTrack(double t0, BPS tempo, const WaveTrack* other)
{
    //
    // Pasting is a bit complicated, because with the existence of multiclip mode,
    // we must guess the behaviour the user wants.
    //
    // Currently, two modes are implemented:
    //
    // - If a single clip should be pasted, and it should be pasted inside another
    //   clip, no NEW clips are generated. The audio is simply inserted.
    //   This resembles the old (pre-multiclip support) behaviour. However, if
    //   the clip is pasted outside of any clip, a NEW clip is generated. This is
    //   the only behaviour which is different to what was done before, but it
    //   shouldn't confuse users too much.
    //
    // - If multiple clips should be pasted, or a single clip that does not fill
    // the duration of the pasted track, these are always pasted as single
    // clips, and the current clip is split, when necessary. This may seem
    // strange at first, but it probably is better than trying to auto-merge
    // anything. The user can still merge the clips by hand (which should be a
    // simple command reachable by a hotkey or single mouse click).
    //

    if (other->GetNumClips() == 0)
        return;

    //wxPrintf("paste: we have at least one clip\n");

    const bool singleClipMode =
       other->GetNumClips() == 1 &&
       std::abs(other->GetStartTime(tempo)) < LongSamplesToTime(1) * 0.5;

    const double insertDuration = other->GetEndTime(tempo);
    const auto rate = GetRate();
    if (insertDuration != 0 && insertDuration < 1.0 / rate)
        // PRL:  I added this check to avoid violations of preconditions in other WaveClip and Sequence
        // methods, but allow the value 0 so I don't subvert the purpose of commit
        // 739422ba70ceb4be0bb1829b6feb0c5401de641e which causes append-recording always to make
        // a new clip.
        return;

    //wxPrintf("Check if we need to make room for the pasted data\n");

    const auto pastingFromTempTrack = !other->GetOwner();
    const bool editClipCanMove = GetEditClipsCanMove();

    // Make room for the pasted data
    if (editClipCanMove) {
        if (!singleClipMode) {
            // We need to insert multiple clips, so split the current clip and ...
            SplitAt(t0, tempo);
        }
        //else if there is a clip at t0 insert new clip inside it and ...

        // ... move everything to the right
        for (const auto& clip : mClipList.Get())
        {
           if (clip->GetPlayStartTime(tempo) > t0 - (1.0 / rate))
              clip->Offset(insertDuration, tempo);
        }
    }

    if (singleClipMode)
    {
        // Single clip mode
        // wxPrintf("paste: checking for single clip mode!\n");

        WaveClip* insideClip = nullptr;

        for (const auto& clip : mClipList.Get())
        {
            if (editClipCanMove)
            {
               if (clip->StrictlyWithinPlayRegion(t0, tempo))
               {
                  // wxPrintf("t0=%.6f: inside clip is %.6f ... %.6f\n",
                  //       t0, clip->GetStartTime(tempo),
                  //       clip->GetEndTime(tempo));
                  insideClip = clip.get();
                  break;
                }
            }
            else
            {
                // If clips are immovable we also allow prepending to clips
                if (
                   clip->StrictlyWithinPlayRegion(t0, tempo) ||
                   TimeToLongSamples(t0) == clip->GetPlayStartSample(tempo))
                {
                    insideClip = clip.get();
                    break;
                }
            }
        }

        if (insideClip)
        {
            // Exhibit traditional behaviour
            //wxPrintf("paste: traditional behaviour\n");
            if (!editClipCanMove)
            {
                // We did not move other clips out of the way already, so
                // check if we can paste without having to move other clips
                for (const auto& clip : mClipList.Get())
                {
                   if (
                      clip->GetPlayStartTime(tempo) >
                         insideClip->GetPlayStartTime(tempo) &&
                      insideClip->GetPlayEndTime(tempo) + insertDuration >
                         clip->GetPlayStartTime(tempo))
                      // Strong-guarantee in case of this path
                      // not that it matters.
                      throw SimpleMessageBoxException {
                         ExceptionType::BadUserAction,
                         XO("There is not enough room available to paste the selection"),
                         XO("Warning"), "Error:_Insufficient_space_in_track"
                      };
                }
            }
            if (auto *pClip = other->GetClipByIndex(0)) {
               bool success = insideClip->Paste(t0, tempo, *pClip);
               // TODO wide wave tracks -- prove success, or propagate failure,
               // or we might throw a MessageBoxException
               // (which would require a change in base class Track)
               // for now it would be quiet failure if clip widths mismatched
               // Can't yet assert(success);
            }
            return;
        }
        // Just fall through and exhibit NEW behaviour
    }

    // Insert NEW clips
    //wxPrintf("paste: multi clip mode!\n");

    if (
       !editClipCanMove &&
       !IsEmpty(t0, t0 + insertDuration - 1.0 / rate, tempo))
       // Strong-guarantee in case of this path
       // not that it matters.
       throw SimpleMessageBoxException {
          ExceptionType::BadUserAction,
          XO("There is not enough room available to paste the selection"),
          XO("Warning"), "Error:_Insufficient_space_in_track"
       };

    for (const auto& clip : other->mClipList.Get())
    {
        // AWD Oct. 2009: Don't actually paste in placeholder clips
        if (!clip->GetIsPlaceholder())
        {
            auto newClip =
                std::make_unique<WaveClip>(*clip, mpFactory, true);
            newClip->Resample(rate);
            newClip->Offset(t0, tempo);
            newClip->MarkChanged();
            if (pastingFromTempTrack)
                //Clips from the tracks which aren't bound to any TrackList are
                //considered to be new entities, thus named using "new" name template
                newClip->SetName(MakeNewClipName());
            else
                newClip->SetName(MakeClipCopyName(clip->GetName()));
            mClipList.PushBack(std::move(newClip)); // transfer ownership
        }
    }
}

bool WaveTrack::RateConsistencyCheck() const
{
   // Assuming a complete track list with consistent channel structure,
   // check only at the leader tracks
   if (!IsLeader())
      return true;

   // The channels and all clips in them should have the same sample rate.
   std::optional<double> oRate;
   auto channels = TrackList::Channels(this);
   return std::all_of(channels.begin(), channels.end(),
      [&](const WaveTrack *pTrack){
         if (!pTrack)
            return false;

         const auto rate = pTrack->mLegacyRate;
         if (!oRate)
            oRate = rate;
         else if (*oRate != rate)
            return false;

         auto &clips = pTrack->mClipList.Get();
         return std::all_of(clips.begin(), clips.end(),
            [rate](auto &pClip){ return pClip->GetRate() == rate; });
      });
}

/*! @excsafety{Weak} */
void WaveTrack::Paste(double t0, BPS tempo, const Track* src)
{
   if (auto other = dynamic_cast<const WaveTrack*>(src))
      PasteWaveTrack(t0, tempo, other);
   else
      // THROW_INCONSISTENCY_EXCEPTION; // ?
      (void)0;// Empty if intentional.
}

void WaveTrack::Silence(double t0, double t1, BPS tempo)
{
   if (t1 < t0)
      THROW_INCONSISTENCY_EXCEPTION;

   auto start = TimeToLongSamples(t0);
   auto end = TimeToLongSamples(t1);

   for (const auto &clip : mClipList.Get())
   {
      auto clipStart = clip->GetPlayStartSample(tempo);
      auto clipEnd = clip->GetPlayEndSample(tempo);

      if (clipEnd > start && clipStart < end)
      {
         auto offset = std::max(start - clipStart, sampleCount(0));
         // Clip sample region and Get/Put sample region overlap
         auto length = std::min(end, clipEnd) - (clipStart + offset);

         clip->SetSilence(offset, length);
      }
   }
}

/*! @excsafety{Strong} */
void WaveTrack::InsertSilence(double t, double len, BPS tempo)
{
   // Nothing to do, if length is zero.
   // Fixes Bug 1626
   if( len == 0 )
      return;
   if (len <= 0)
      THROW_INCONSISTENCY_EXCEPTION;

   if (mClipList.Empty())
   {
      // Special case if there is no clip yet
      // TODO wide wave tracks -- match clip width
      auto clip = std::make_shared<WaveClip>(1,
         mpFactory, mFormat, GetRate(), this->GetWaveColorIndex());
      clip->InsertSilence(0, len, tempo);
      // use No-fail-guarantee
      mClipList.PushBack( std::move( clip ) );
      return;
   }
   else {
      // Assume at most one clip contains t
      const auto end = mClipList.End();
      const auto it =
         std::find_if(mClipList.Begin(), end, [&](const WaveClipHolder& clip) {
            return clip->StrictlyWithinPlayRegion(t, tempo);
         });

      // use Strong-guarantee
      if (it != end)
         it->get()->InsertSilence(t, len, tempo);

      // use No-fail-guarantee
      for (const auto &clip : mClipList.Get())
      {
         if (clip->BeforeOrAtPlayStartTime(t, tempo))
            clip->Offset(len, tempo);
      }
   }
}

//Performs the opposite of Join
//Analyses selected region for possible Joined clips and disjoins them
/*! @excsafety{Weak} */
void WaveTrack::Disjoin(double t0, double t1, BPS tempo)
{
   auto minSamples = TimeToLongSamples( WAVETRACK_MERGE_POINT_TOLERANCE );
   const size_t maxAtOnce = 1048576;
   std::vector<float> buffer;
   std::vector<samplePtr> buffers;
   Regions regions;

   // TODO wide wave tracks -- only need to change width
   const size_t width = 1;
   for (const auto &clip : mClipList.Get()) {
      double startTime = clip->GetPlayStartTime(tempo);
      double endTime = clip->GetPlayEndTime(tempo);

      if( endTime < t0 || startTime > t1 )
         continue;

      // Assume all clips will have the same width
      if (buffer.empty()) {
         buffer.resize(maxAtOnce * width);
         buffers.resize(width);
         auto pBuffer = buffer.data();
         for (size_t ii = 0; ii < width; ++ii, pBuffer += maxAtOnce)
            buffers[ii] = reinterpret_cast<samplePtr>(pBuffer);
      }

      const auto allZeroesAt = [&](size_t i) {
         auto pData = buffer.data() + i;
         for (size_t ii = 0; ii < width; ++ii, pData += maxAtOnce) {
            if (*pData != 0.0)
               return false;
         }
         return true;
      };

      // simply look for a sequence of zeroes (across all channels) and if the
      // sequence is longer than the minimum number, split-delete the region

      sampleCount seqStart = -1;
      auto start = clip->TimeToSamples(std::max(.0, t0 - startTime));
      auto end = clip->TimeToSamples(std::min(endTime, t1) - startTime);

      auto len = ( end - start );
      for( decltype(len) done = 0; done < len; done += maxAtOnce )
      {
         auto numSamples = limitSampleBufferSize( maxAtOnce, len - done );

         clip
            ->GetSamples(buffers.data(), floatSample, start + done, numSamples);
         for( decltype(numSamples) i = 0; i < numSamples; i++ )
         {
            auto curSamplePos = start + done + i;

            //start a NEW sequence
            if (seqStart == -1 && allZeroesAt(i))
               seqStart = curSamplePos;
            else if (curSamplePos == end - 1 || !allZeroesAt(i))
            {
               if( seqStart != -1 )
               {
                  decltype(end) seqEnd;

                  //consider the end case, where selection ends in zeroes
                  if (curSamplePos == end - 1 && allZeroesAt(i))
                     seqEnd = end;
                  else
                     seqEnd = curSamplePos;
                  if (seqEnd - seqStart + 1 > minSamples)
                  {
                     regions.push_back(
                        Region(
                           startTime + clip->SamplesToTime(seqStart),
                           startTime + clip->SamplesToTime(seqEnd)
                        )
                     );
                  }
                  seqStart = -1;
               }
            }
         }
      }
   }

   for( unsigned int i = 0; i < regions.size(); i++ )
   {
      const Region &region = regions.at(i);
      SplitDelete(region.start, region.end, tempo);
   }
}

/*! @excsafety{Weak} */
void WaveTrack::Join(double t0, double t1, BPS tempo)
{
   // Merge all WaveClips overlapping selection into one

   WaveClipPointers clipsToDelete;
   WaveClip* newClip{};

   const auto rate = GetRate();
   for (const auto &clip: mClipList.Get())
   {
      if (
         clip->GetPlayStartTime(tempo) < t1 - (1.0 / rate) &&
         clip->GetPlayEndTime(tempo) - (1.0 / rate) > t0)
      {

         // Put in sorted order
         auto it = clipsToDelete.begin(), end = clipsToDelete.end();
         for (; it != end; ++it)
            if ((*it)->GetPlayStartTime(tempo) > clip->GetPlayStartTime(tempo))
               break;
         // wxPrintf("Insert clip %.6f at position %d\n",
         // clip->GetStartTime(tempo), i);
         clipsToDelete.insert(it, clip.get());
      }
   }

   //if there are no clips to DELETE, nothing to do
   if( clipsToDelete.size() == 0 )
      return;

   auto t = clipsToDelete[0]->GetPlayStartTime(tempo);
   //preserve left trim data if any
   newClip = CreateClip(
      clipsToDelete[0]->GetSequenceStartTime(),
      clipsToDelete[0]->GetName());

   for (const auto &clip : clipsToDelete)
   {
      // wxPrintf("t=%.6f adding clip (offset %.6f, %.6f ... %.6f)\n",
      //       t, clip->GetOffset(), clip->GetStartTime(tempo),
      //       clip->GetEndTime(tempo));

      if (clip->GetPlayStartTime(tempo) - t > (1.0 / rate))
      {
         double addedSilence = (clip->GetPlayStartTime(tempo) - t);
         //wxPrintf("Adding %.6f seconds of silence\n");
         auto offset = clip->GetPlayStartTime(tempo);
         auto value = clip->GetEnvelope()->GetValue( offset );
         newClip->AppendSilence(addedSilence, tempo, value);
         t += addedSilence;
      }

      //wxPrintf("Pasting at %.6f\n", t);
      bool success = newClip->Paste(t, tempo, *clip);
      assert(success); // promise of CreateClip

      t = newClip->GetPlayEndTime(tempo);

      auto it = FindClip(mClipList.Get(), clip);
      mClipList.Erase(it); // deletes the clip
   }
}

/*! @excsafety{Partial}
-- Some prefix (maybe none) of the buffer is appended,
and no content already flushed to disk is lost. */
bool WaveTrack::Append(constSamplePtr buffer, sampleFormat format,
   size_t len, unsigned int stride, sampleFormat effectiveFormat)
{
   constSamplePtr buffers[]{ buffer };
   return RightmostOrNewClip()
      ->Append(buffers, format, len, stride, effectiveFormat);
}

/*! @excsafety{Mixed} */
/*! @excsafety{No-fail} -- The rightmost clip will be in a flushed state. */
/*! @excsafety{Partial}
-- Some initial portion (maybe none) of the append buffer of the rightmost
clip gets appended; no previously saved contents are lost. */
void WaveTrack::Flush()
{
   // After appending, presumably.  Do this to the clip that gets appended.
   RightmostOrNewClip()->Flush();
}

bool WaveTrack::IsLeader() const
{
   return Track::IsLeader();
}

bool WaveTrack::GetMute() const
{
   return PlayableTrack::GetMute();
}

bool WaveTrack::GetSolo() const
{
   return PlayableTrack::GetSolo();
}

bool WaveTrack::HandleXMLTag(const std::string_view& tag, const AttributesList &attrs)
{
   if (tag == "wavetrack") {
      double dblValue;
      long nValue;

      for (auto pair : attrs)
      {
         auto attr = pair.first;
         auto value = pair.second;

         if (attr == "rate")
         {
            // mRate is an int, but "rate" in the project file is a float.
            if (!value.TryGet(dblValue) ||
                  (dblValue < 1.0) || (dblValue > 1000000.0)) // allow a large range to be read
               return false;

            // Defer the setting of rate until LinkConsistencyFix
            mLegacyRate = lrint(dblValue);
         }
         else if (attr == "offset" && value.TryGet(dblValue))
         {
            // Offset is only relevant for legacy project files. The value
            // is cached until the actual WaveClip containing the legacy
            // track is created.
            mLegacyProjectFileOffset = dblValue;
         }
         else if (this->WritableSampleTrack::HandleXMLAttribute(attr, value))
         {}
         else if (this->Track::HandleCommonXMLAttribute(attr, value))
            ;
         else if (attr == "gain" && value.TryGet(dblValue))
            DoSetGain(dblValue);
         else if (attr == "pan" && value.TryGet(dblValue) &&
                  (dblValue >= -1.0) && (dblValue <= 1.0))
            DoSetPan(dblValue);
         else if (attr == "linked" && value.TryGet(nValue))
            SetLinkType(ToLinkType(nValue), false);
         else if (attr == "colorindex" && value.TryGet(nValue))
            // Don't use SetWaveColorIndex as it sets the clips too.
            mWaveColorIndex  = nValue;
         else if (attr == "sampleformat" && value.TryGet(nValue) &&
                  Sequence::IsValidSampleFormat(nValue))
            mFormat = static_cast<sampleFormat>(nValue);
      } // while
      return true;
   }

   return false;
}

void WaveTrack::HandleXMLEndTag(const std::string_view&  WXUNUSED(tag))
{
#if 0
   // In case we opened a pre-multiclip project, we need to
   // simulate closing the waveclip tag.
   NewestOrNewClip()->HandleXMLEndTag("waveclip");
#else
   // File compatibility breaks have intervened long since, and the line above
   // would now have undesirable side effects
#endif

   // Make clips (which don't serialize the rate) consistent with channel rate,
   // though the consistency check of channels with each other remains to do
   if (mLegacyRate > 0)
      SetClipRates(mLegacyRate);
}

XMLTagHandler *WaveTrack::HandleXMLChild(const std::string_view& tag)
{
   if ( auto pChild = WaveTrackIORegistry::Get()
          .CallObjectAccessor(tag, *this) )
      return pChild;

   assert(false);
   constexpr BPS tempo { 120 }; // todo(mhodgkinson) what do we do here?
   //
   // This is legacy code (1.2 and previous) and is not called for NEW projects!
   //
   if (tag == "sequence" || tag == "envelope")
   {
      // This is a legacy project, so set the cached offset
      NewestOrNewClip()->SetSequenceStartTime(mLegacyProjectFileOffset, tempo);

      // Legacy project file tracks are imported as one single wave clip
      if (tag == "sequence")
         return NewestOrNewClip()->GetSequence(0);
      else if (tag == "envelope")
         return NewestOrNewClip()->GetEnvelope();
   }

   // JKC... for 1.1.0, one step better than what we had, but still badly broken.
   // If we see a waveblock at this level, we'd better generate a sequence.
   if (tag == "waveblock")
   {
      // This is a legacy project, so set the cached offset
      NewestOrNewClip()->SetSequenceStartTime(mLegacyProjectFileOffset, tempo);
      Sequence *pSeq = NewestOrNewClip()->GetSequence(0);
      return pSeq;
   }

   //
   // This is for the NEW file format (post-1.2)
   //
   if (tag == "waveclip")
      return CreateClip();

   return nullptr;
}

void WaveTrack::WriteXML(XMLWriter &xmlFile) const
// may throw
{
   xmlFile.StartTag(wxT("wavetrack"));
   this->Track::WriteCommonXMLAttributes( xmlFile );
   xmlFile.WriteAttr(wxT("linked"), static_cast<int>(GetLinkType()));
   this->WritableSampleTrack::WriteXMLAttributes(xmlFile);
   xmlFile.WriteAttr(wxT("rate"), GetRate());

   // Some values don't vary independently in channels but have been written
   // redundantly for each channel.  Keep doing this in 3.4 and later in case
   // a project is opened in an earlier version.
   xmlFile.WriteAttr(wxT("gain"), static_cast<double>(GetGain()));
   xmlFile.WriteAttr(wxT("pan"), static_cast<double>(GetPan()));
   xmlFile.WriteAttr(wxT("colorindex"), mWaveColorIndex );

   xmlFile.WriteAttr(wxT("sampleformat"), static_cast<long>(mFormat) );

   WaveTrackIORegistry::Get().CallWriters(*this, xmlFile);

   for (const auto &clip : mClipList.Get())
   {
      clip->WriteXML(xmlFile);
   }

   xmlFile.EndTag(wxT("wavetrack"));
}

std::optional<TranslatableString> WaveTrack::GetErrorOpening() const
{
   for (const auto &clip : mClipList.Get())
      for (size_t ii = 0, width = clip->GetWidth(); ii < width; ++ii)
         if (clip->GetSequence(ii)->GetErrorOpening())
            return XO("A track has a corrupted sample sequence.");

   if (!RateConsistencyCheck())
      return XO(
"This project cannot be opened because it contains a stereo track with "
"different sample rates. This functionality is no longer supported since the "
"release of Audacity version 3.4");

   return {};
}

bool WaveTrack::CloseLock() noexcept
{
   for (const auto &clip : mClipList.Get())
      clip->CloseLock();

   return true;
}

ClipConstHolders WaveTrack::GetClipInterfaces() const
{
   assert(IsLeader());
   const auto pOwner = GetOwner();
   ClipConstHolders wideClips;
   wideClips.reserve(mClipList.Size());
   for (auto clipIndex = 0u; clipIndex < mClipList.Size(); ++clipIndex)
   {
      const auto leftClip = mClipList[clipIndex];
      const auto rightClip =
         NChannels() == 2u && pOwner ?
            (*++pOwner->Find<const WaveTrack>(this))->mClipList[clipIndex] :
            nullptr;
      wideClips.emplace_back(std::make_shared<WideClip>(leftClip, rightClip));
   }
   return wideClips;
}

double WaveTrack::GetStartTime(BPS tempo) const
{
   bool found = false;
   double best = 0.0;

   if (mClipList.Empty())
      return 0;

   for (const auto &clip : mClipList.Get())
      if (!found)
      {
         found = true;
         best = clip->GetPlayStartTime(tempo);
      }
      else if (clip->GetPlayStartTime(tempo) < best)
         best = clip->GetPlayStartTime(tempo);

   return best;
}

double WaveTrack::GetEndTime(BPS tempo) const
{
   return GetEndTime(
      [tempo](const WaveClip& clip) { return clip.GetPlayEndTime(tempo); });
}

double WaveTrack::GetEndTime(
   const std::function<double(const WaveClip&)>& endTimeGetter) const
{
   bool found = false;
   double best = 0.0;

   if (mClipList.Empty())
      return 0;

   for (const auto &clip : mClipList.Get())
      if (!found)
      {
         found = true;
         best = endTimeGetter(*clip);
      }
      else if (endTimeGetter(*clip) > best)
         best = endTimeGetter(*clip);

   return best;
}

//
// Getting/setting samples.  The sample counts here are
// expressed relative to t=0.0 at the track's sample rate.
//

std::pair<float, float>
WaveTrack::GetMinMax(double t0, double t1, BPS tempo, bool mayThrow) const
{
   std::pair<float, float> results {
      // we need these at extremes to make sure we find true min and max
      FLT_MAX, -FLT_MAX
   };
   bool clipFound = false;

   if (t0 > t1) {
      if (mayThrow)
         THROW_INCONSISTENCY_EXCEPTION;
      return results;
   }

   if (t0 == t1)
      return results;

   for (const auto &clip: mClipList.Get())
   {
      if (
         t1 >= clip->GetPlayStartTime(tempo) &&
         t0 <= clip->GetPlayEndTime(tempo))
      {
         clipFound = true;
         // TODO wide wave tracks -- choose correct channel
         auto clipResults = clip->GetMinMax(0, t0, t1, tempo, mayThrow);
         if (clipResults.first < results.first)
            results.first = clipResults.first;
         if (clipResults.second > results.second)
            results.second = clipResults.second;
      }
   }

   if(!clipFound)
   {
      results = { 0.f, 0.f }; // sensible defaults if no clips found
   }

   return results;
}

float WaveTrack::GetRMS(double t0, double t1, BPS tempo, bool mayThrow) const
{
   if (t0 > t1) {
      if (mayThrow)
         THROW_INCONSISTENCY_EXCEPTION;
      return 0.f;
   }

   if (t0 == t1)
      return 0.f;

   double sumsq = 0.0;
   sampleCount length = 0;

   for (const auto &clip: mClipList.Get())
   {
      // If t1 == clip->GetStartTime(tempo) or t0 == clip->GetEndTime(tempo),
      // then the clip is not inside the selection, so we don't want it. if (t1
      // >= clip->GetStartTime(tempo) && t0 <= clip->GetEndTime(tempo))
      if (
         t1 >= clip->GetPlayStartTime(tempo) &&
         t0 <= clip->GetPlayEndTime(tempo))
      {
         auto clipStart = clip->TimeToSequenceSamples(
            std::max(t0, clip->GetPlayStartTime(tempo)), tempo);
         auto clipEnd = clip->TimeToSequenceSamples(
            std::min(t1, clip->GetPlayEndTime(tempo)), tempo);

         // TODO wide wave tracks -- choose correct channel
         float cliprms = clip->GetRMS(0, t0, t1, tempo, mayThrow);

         sumsq += cliprms * cliprms * (clipEnd - clipStart).as_float();
         length += (clipEnd - clipStart);
      }
   }
   return length > 0 ? sqrt(sumsq / length.as_double()) : 0.0;
}

bool WaveTrack::Get(
   size_t iChannel, size_t nBuffers, samplePtr buffers[], sampleFormat format,
   sampleCount start, size_t len, BPS tempo, bool backwards, fillFormat fill,
   bool mayThrow, sampleCount* pNumWithinClips) const
{
   // A WaveTrack isn't capable of returning samples, since it cannot stretch
   // raw data to the project tempo.
   assert(false);
   return false;
}

std::vector<ChannelSampleView> WaveTrack::GetSampleView(
   size_t iChannel, size_t nBuffers, sampleCount start, size_t length,
   BPS tempo, bool backwards) const
{
   assert(false);
   return {};
}

/*! @excsafety{Weak} */
void WaveTrack::Set(
   constSamplePtr buffer, sampleFormat format, sampleCount start, size_t len,
   BPS tempo, sampleFormat effectiveFormat)
{
   assert(false);
}

sampleFormat WaveTrack::WidestEffectiveFormat() const
{
   auto result = narrowestSampleFormat;
   const auto accumulate = [&](const WaveTrack &track) {
      for (const auto &pClip : track.GetClips())
         for (size_t ii = 0, width = pClip->GetWidth(); ii < width; ++ii)
            result = std::max(result,
               pClip->GetSequence(ii)->GetSampleFormats().Effective());
   };
   if (auto pOwner = GetOwner()) {
      for (auto channel : TrackList::Channels(this))
         accumulate(*channel);
   }
   else
      accumulate(*this);
   return result;
}

bool WaveTrack::HasTrivialEnvelope() const
{
   auto &clips = GetClips();
   return std::all_of(clips.begin(), clips.end(),
      [](const auto &pClip){ return pClip->GetEnvelope()->IsTrivial(); });
}

void WaveTrack::GetEnvelopeValues(
   double* buffer, size_t bufferLen, double t0, BPS tempo, bool backwards) const
{
   if (backwards)
      t0 -= bufferLen / GetRate();
   // The output buffer corresponds to an unbroken span of time which the callers expect
   // to be fully valid.  As clips are processed below, the output buffer is updated with
   // envelope values from any portion of a clip, start, end, middle, or none at all.
   // Since this does not guarantee that the entire buffer is filled with values we need
   // to initialize the entire buffer to a default value.
   //
   // This does mean that, in the cases where a usable clip is located, the buffer value will
   // be set twice.  Unfortunately, there is no easy way around this since the clips are not
   // stored in increasing time order.  If they were, we could just track the time as the
   // buffer is filled.
   for (decltype(bufferLen) i = 0; i < bufferLen; i++)
   {
      buffer[i] = 1.0;
   }

   double startTime = t0;
   const auto rate = GetRate();
   auto tstep = 1.0 / rate;
   double endTime = t0 + tstep * bufferLen;
   for (const auto &clip: mClipList.Get())
   {
      // IF clip intersects startTime..endTime THEN...
      auto dClipStartTime = clip->GetPlayStartTime(tempo);
      auto dClipEndTime = clip->GetPlayEndTime(tempo);
      if ((dClipStartTime < endTime) && (dClipEndTime > startTime))
      {
         auto rbuf = buffer;
         auto rlen = bufferLen;
         auto rt0 = t0;

         if (rt0 < dClipStartTime)
         {
            // This is not more than the number of samples in
            // (endTime - startTime) which is bufferLen:
            auto nDiff = (sampleCount)floor((dClipStartTime - rt0) * rate + 0.5);
            auto snDiff = nDiff.as_size_t();
            rbuf += snDiff;
            wxASSERT(snDiff <= rlen);
            rlen -= snDiff;
            rt0 = dClipStartTime;
         }

         if (rt0 + rlen*tstep > dClipEndTime)
         {
            auto nClipLen =
               clip->GetPlayEndSample(tempo) - clip->GetPlayStartSample(tempo);

            if (nClipLen <= 0) // Testing for bug 641, this problem is consistently '== 0', but doesn't hurt to check <.
               return;

            // This check prevents problem cited in http://bugzilla.audacityteam.org/show_bug.cgi?id=528#c11,
            // Gale's cross_fade_out project, which was already corrupted by bug 528.
            // This conditional prevents the previous write past the buffer end, in clip->GetEnvelope() call.
            // Never increase rlen here.
            // PRL bug 827:  rewrote it again
            rlen = limitSampleBufferSize( rlen, nClipLen );
            rlen = std::min(rlen, size_t(floor(0.5 + (dClipEndTime - rt0) / tstep)));
         }
         // Samples are obtained for the purpose of rendering a wave track,
         // so quantize time
         clip->GetEnvelope()->GetValues(rbuf, rlen, rt0, tstep);
      }
   }
   if (backwards)
      std::reverse(buffer, buffer + bufferLen);
}

// When the time is both the end of a clip and the start of the next clip, the
// latter clip is returned.
WaveClip* WaveTrack::GetClipAtTime(double time, BPS tempo)
{

   const auto clips = SortedClipArray();
   auto p =
      std::find_if(clips.rbegin(), clips.rend(), [&](WaveClip* const& clip) {
         return time >= clip->GetPlayStartTime(tempo) &&
                time <= clip->GetPlayEndTime(tempo);
      });

   // When two clips are immediately next to each other, the
   // GetPlayEndTime(tempo) of the first clip and the GetPlayStartTime(tempo) of
   // the second clip may not be exactly equal due to rounding errors. If "time"
   // is the end time of the first of two such clips, and the end time is
   // slightly less than the start time of the second clip, then the first
   // rather than the second clip is found by the above code. So correct this.
   if (
      p != clips.rend() && p != clips.rbegin() &&
      time == (*p)->GetPlayEndTime(tempo) &&
      (*p)->SharesBoundaryWithNextClip(*(p - 1), tempo))
   {
      p--;
   }

   return p != clips.rend() ? *p : nullptr;
}

Envelope* WaveTrack::GetEnvelopeAtTime(double time, BPS tempo)
{
   WaveClip* clip = GetClipAtTime(time, tempo);
   if (clip)
      return clip->GetEnvelope();
   else
      return NULL;
}

WaveClip* WaveTrack::CreateClip(Beat offset, const wxString& name)
{
   // TODO wide wave tracks -- choose clip width correctly for the track
   auto clip = std::make_shared<WaveClip>(1,
      mpFactory, mFormat, GetRate(), GetWaveColorIndex());
   clip->SetName(name);
   clip->SetSequenceStartTime(offset);
   mClipList.PushBack(std::move(clip));

   auto result = mClipList.Back().get();
   // TODO wide wave tracks -- for now assertion is correct because widths are
   // always 1
   assert(result->GetWidth() == GetWidth());
   return result;
}

WaveClip* WaveTrack::NewestOrNewClip()
{
   if (mClipList.Empty()) {
      return CreateClip(mOffset, MakeNewClipName());
   }
   else
      return mClipList.Back().get();
}

/*! @excsafety{No-fail} */
WaveClip* WaveTrack::RightmostOrNewClip()
{
   if (mClipList.Empty()) {
      return CreateClip(mOffset, MakeNewClipName());
   }
   else
   {
      auto it = mClipList.Begin();
      WaveClip *rightmost = (*it++).get();
      Beat maxOffset = rightmost->GetPlayStartTime();
      for (auto end = mClipList.End(); it != end; ++it)
      {
         WaveClip *clip = it->get();
         Beat offset = clip->GetPlayStartTime();
         if (maxOffset < offset)
            maxOffset = offset, rightmost = clip;
      }
      return rightmost;
   }
}

int WaveTrack::GetClipIndex(const WaveClip* clip) const
{
   int result;
   FindClip(mClipList.Get(), clip, &result);
   return result;
}

WaveClip* WaveTrack::GetClipByIndex(int index)
{
   if(index < (int)mClipList.Size())
      return mClipList[index].get();
   else
      return nullptr;
}

const WaveClip* WaveTrack::GetClipByIndex(int index) const
{
   return const_cast<WaveTrack&>(*this).GetClipByIndex(index);
}

int WaveTrack::GetNumClips() const
{
   return mClipList.Size();
}

bool WaveTrack::CanOffsetClips(
   const std::vector<WaveClip*>& clips, BPS tempo, double amount,
   double* allowedAmount /* = NULL */)
{
   if (allowedAmount)
      *allowedAmount = amount;

   const auto &moving = [&](WaveClip *clip){
      // linear search might be improved, but expecting few moving clips
      // compared with the fixed clips
      return clips.end() != std::find( clips.begin(), clips.end(), clip );
   };

   const Beat beatAmount { amount * tempo.get() };

   for (const auto &c: mClipList.Get()) {
      if ( moving( c.get() ) )
         continue;
      for (const auto clip : clips) {
         if (
            c->GetPlayStartTime() < clip->GetPlayEndTime() + beatAmount &&
            c->GetPlayEndTime() > clip->GetPlayStartTime() + beatAmount)
         {
            if (!allowedAmount)
               return false; // clips overlap

            if (amount > 0)
            {
               if (
                  c->GetPlayStartTime(tempo) - clip->GetPlayEndTime(tempo) <
                  *allowedAmount)
                  *allowedAmount =
                     c->GetPlayStartTime(tempo) - clip->GetPlayEndTime(tempo);
               if (*allowedAmount < 0)
                  *allowedAmount = 0;
            } else
            {
               if (
                  c->GetPlayEndTime(tempo) - clip->GetPlayStartTime(tempo) >
                  *allowedAmount)
                  *allowedAmount =
                     c->GetPlayEndTime(tempo) - clip->GetPlayStartTime(tempo);
               if (*allowedAmount > 0)
                  *allowedAmount = 0;
            }
         }
      }
   }

   if (allowedAmount)
   {
      if (*allowedAmount == amount)
         return true;

      // Check if the NEW calculated amount would not violate
      // any other constraint
      if (!CanOffsetClips(clips, tempo, *allowedAmount, nullptr))
      {
         *allowedAmount = 0; // play safe and don't allow anything
         return false;
      }
      else
         return true;
   } else
      return true;
}

bool WaveTrack::CanInsertClip(
   WaveClip* clip, BPS tempo, double& slideBy, double& tolerance) const
{
   for (const auto &c : mClipList.Get())
   {
      //VS: Do we need to take into account sample rate difference?
      double d1 =
         c->GetPlayStartTime(tempo) - (clip->GetPlayEndTime(tempo) + slideBy);
      double d2 =
         (clip->GetPlayStartTime(tempo) + slideBy) - c->GetPlayEndTime(tempo);
      if ( (d1<0) &&  (d2<0) )
      {
         // clips overlap.
         // Try to rescue it.
         // The rescue logic is not perfect, and will typically
         // move the clip at most once.
         // We divide by 1000 rather than set to 0, to allow for
         // a second 'micro move' that is really about rounding error.

         // VS: clip could be moved more than once, moving it in opposite
         // direction may reintroduce overlapping condition
         if( -d1 < tolerance ){
            // right edge of clip overlaps slightly.
            // slide clip left a small amount.
            slideBy +=d1;
            tolerance /=1000;
         } else if( -d2 < tolerance ){
            // left edge of clip overlaps slightly.
            // slide clip right a small amount.
            slideBy -= d2;
            tolerance /=1000;
         }
         else
            return false; // clips overlap  No tolerance left.
      }
   }

   return true;
}

/*! @excsafety{Weak} */
void WaveTrack::Split(double t0, double t1, BPS tempo)
{
   SplitAt(t0, tempo);
   if( t0 != t1 )
      SplitAt(t1, tempo);
}

/*! @excsafety{Weak} */
void WaveTrack::SplitAt(double t, BPS tempo)
{
   for (const auto &c : mClipList.Get())
   {
      if (c->StrictlyWithinPlayRegion(t, tempo))
      {
         t = LongSamplesToTime(TimeToLongSamples(t));
         auto newClip = std::make_unique<WaveClip>( *c, mpFactory, true );
         c->TrimRightTo(t, tempo); // put t on a sample
         newClip->TrimLeftTo(t, tempo);

         // This could invalidate the iterators for the loop!  But we return
         // at once so it's okay
         mClipList.PushBack(std::move(newClip)); // transfer ownership
         return;
      }
   }
}

// Expand cut line (that is, re-insert audio, then DELETE audio saved in cut line)
/*! @excsafety{Strong} */
void WaveTrack::ExpandCutLine(
   BPS tempo, double cutLinePosition, double* cutlineStart, double* cutlineEnd)
{
   bool editClipCanMove = GetEditClipsCanMove();

   // Find clip which contains this cut line
   double start = 0, end = 0;
   auto pEnd = mClipList.End();
   auto pClip =
      std::find_if(mClipList.Begin(), pEnd, [&](const WaveClipHolder& clip) {
         return clip->FindCutLine(cutLinePosition, tempo, &start, &end);
      });
   if (pClip != pEnd)
   {
      auto &clip = *pClip;
      if (!editClipCanMove)
      {
         // We are not allowed to move the other clips, so see if there
         // is enough room to expand the cut line
         for (const auto &clip2: mClipList.Get())
         {
            if (
               clip2->GetPlayStartTime(tempo) > clip->GetPlayStartTime(tempo) &&
               clip->GetPlayEndTime(tempo) + end - start >
                  clip2->GetPlayStartTime(tempo))
               // Strong-guarantee in case of this path
               throw SimpleMessageBoxException{
                  ExceptionType::BadUserAction,
                  XO("There is not enough room available to expand the cut line"),
                  XO("Warning"),
                  "Error:_Insufficient_space_in_track"
               };
          }
      }

      clip->ExpandCutLine(cutLinePosition, tempo);

      // Strong-guarantee provided that the following gives No-fail-guarantee

      if (cutlineStart)
         *cutlineStart = start;
      if (cutlineEnd)
         *cutlineEnd = end;

      // Move clips which are to the right of the cut line
      if (editClipCanMove)
      {
         for (const auto &clip2 : mClipList.Get())
         {
            if (clip2->GetPlayStartTime(tempo) > clip->GetPlayStartTime(tempo))
               clip2->Offset(end - start, tempo);
         }
      }
   }
}

bool WaveTrack::RemoveCutLine(double cutLinePosition, BPS tempo)
{
   for (const auto &clip : mClipList.Get())
      if (clip->RemoveCutLine(cutLinePosition, tempo))
         return true;

   return false;
}

/*! @excsafety{Strong} */
void WaveTrack::MergeClips(int clipidx1, int clipidx2)
{
   WaveClip* clip1 = GetClipByIndex(clipidx1);
   WaveClip* clip2 = GetClipByIndex(clipidx2);

   if (!clip1 || !clip2) // Could happen if one track of a linked pair had a split and the other didn't.
      return; // Don't throw, just do nothing.

   // Append data from second clip to first clip
   // use Strong-guarantee
   clip1->Paste(clip1->GetPlayEndTime(), *clip2);

   // use No-fail-guarantee for the rest
   // Delete second clip
   auto it = FindClip(mClipList.Get(), clip2);
   mClipList.Erase(it);
}

/*! @excsafety{Weak} -- Partial completion may leave clips at differing sample rates!
*/
void WaveTrack::Resample(int rate, BasicUI::ProgressDialog *progress)
{
   for (const auto &clip : mClipList.Get())
      clip->Resample(rate, progress);

   SetRate(rate);
}

namespace {
   template < typename Cont1, typename Cont2 >
   Cont1 FillSortedClipArray(const Cont2& mClips)
   {
      Cont1 clips;
      for (const auto &clip : mClips)
         clips.push_back(clip.get());
      std::sort(
         clips.begin(), clips.end(), [](const WaveClip* a, const WaveClip* b) {
            return a->GetPlayStartTime() < b->GetPlayStartTime();
         });
      return clips;
   }
}

WaveClipPointers WaveTrack::SortedClipArray()
{
   return FillSortedClipArray<WaveClipPointers>(mClipList.Get());
}

WaveClipConstPointers WaveTrack::SortedClipArray() const
{
   return FillSortedClipArray<WaveClipConstPointers>(mClipList.Get());
}

auto WaveTrack::AllClipsIterator::operator ++ () -> AllClipsIterator &
{
   // The unspecified sequence is a post-order, but there is no
   // promise whether sister nodes are ordered in time.
   if ( !mStack.empty() ) {
      auto &pair =  mStack.back();
      if ( ++pair.first == pair.second ) {
         mStack.pop_back();
      }
      else
         push( (*pair.first)->GetCutLines() );
   }

   return *this;
}

void WaveTrack::AllClipsIterator::push(const WaveClipHolders &clips )
{
   auto pClips = &clips;
   while (!pClips->empty()) {
      auto first = pClips->begin();
      mStack.push_back( Pair( first, pClips->end() ) );
      pClips = &(*first)->GetCutLines();
   }
}

#include "SampleBlock.h"
void VisitBlocks(TrackList &tracks, BlockVisitor visitor,
   SampleBlockIDSet *pIDs)
{
   for (auto wt : tracks.Any< const WaveTrack >()) {
      // Scan all clips within current track
      for(const auto &clip : wt->GetAllClips()) {
         // Scan all sample blocks within current clip
         for (size_t ii = 0, width = clip->GetWidth(); ii < width; ++ii) {
            auto blocks = clip->GetSequenceBlockArray(ii);
            for (const auto &block : *blocks) {
               auto &pBlock = block.sb;
               if ( pBlock ) {
                  if ( pIDs && !pIDs->insert(pBlock->GetBlockID()).second )
                     continue;
                  if ( visitor )
                     visitor( *pBlock );
               }
            }
         }
      }
   }
}

void InspectBlocks(const TrackList &tracks, BlockInspector inspector,
   SampleBlockIDSet *pIDs)
{
   VisitBlocks(
      const_cast<TrackList &>(tracks), std::move( inspector ), pIDs );
}

#include "Project.h"
#include "SampleBlock.h"
static auto TrackFactoryFactory = [](AudacityProject& project) {
   return std::make_shared<WaveTrackFactory>(
      ProjectRate::Get(project), SampleBlockFactory::New(project));
};

static const AudacityProject::AttachedObjects::RegisteredFactory key2{
   TrackFactoryFactory
};

WaveTrackFactory &WaveTrackFactory::Get( AudacityProject &project )
{
   return project.AttachedObjects::Get< WaveTrackFactory >( key2 );
}

const WaveTrackFactory &WaveTrackFactory::Get( const AudacityProject &project )
{
   return Get( const_cast< AudacityProject & >( project ) );
}

WaveTrackFactory &WaveTrackFactory::Reset( AudacityProject &project )
{
   auto result = TrackFactoryFactory( project );
   project.AttachedObjects::Assign( key2, result );
   return *result;
}

void WaveTrackFactory::Destroy( AudacityProject &project )
{
   project.AttachedObjects::Assign( key2, nullptr );
}

ProjectFormatExtensionsRegistry::Extension smartClipsExtension(
   [](const AudacityProject& project) -> ProjectFormatVersion
   {
      const TrackList& trackList = TrackList::Get(project);

      for (auto wt : trackList.Any<const WaveTrack>())
      {
         for (const auto& clip : wt->GetAllClips())
         {
            if (
               clip->GetTrimLeft() > Beat { 0.0 } ||
               clip->GetTrimRight() > Beat { 0.0 })
               return { 3, 1, 0, 0 };
         }
      }

      return BaseProjectFormatVersion;
   }
);

StringSetting AudioTrackNameSetting{
   L"/GUI/TrackNames/DefaultTrackName",
   // Computed default value depends on chosen language
   []{ return DefaultName.Translation(); }
};

// Bug 825 is essentially that SyncLock requires EditClipsCanMove.
// SyncLock needs rethinking, but meanwhile this function
// fixes the issues of Bug 825 by allowing clips to move when in
// SyncLock.
bool GetEditClipsCanMove()
{
   bool mIsSyncLocked = SyncLockTracks.Read();
   if( mIsSyncLocked )
      return true;
   bool editClipsCanMove;
   return EditClipsCanMove.Read();
}

BoolSetting EditClipsCanMove{
   L"/GUI/EditClipCanMove",         false  };

DEFINE_XML_METHOD_REGISTRY( WaveTrackIORegistry );
